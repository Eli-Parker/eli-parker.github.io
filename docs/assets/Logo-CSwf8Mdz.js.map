{"version":3,"file":"Logo-CSwf8Mdz.js","sources":["../../../node_modules/three-stdlib/geometries/TextGeometry.js","../../../node_modules/three-stdlib/loaders/FontLoader.js","../../../node_modules/@react-three/drei/core/useFont.js","../../../node_modules/@react-three/drei/core/Text3D.js","../../../node_modules/@react-three/drei/core/Center.js","../../utils/Helpers.jsx","../../utils/TitleText3D.jsx","../../../node_modules/three/examples/jsm/utils/SkeletonUtils.js","../../contact/Logo.jsx"],"sourcesContent":["import { ExtrudeGeometry } from \"three\";\nclass TextGeometry extends ExtrudeGeometry {\n  constructor(text, parameters = {}) {\n    const {\n      bevelEnabled = false,\n      bevelSize = 8,\n      bevelThickness = 10,\n      font,\n      height = 50,\n      size = 100,\n      lineHeight = 1,\n      letterSpacing = 0,\n      ...rest\n    } = parameters;\n    if (font === void 0) {\n      super();\n    } else {\n      const shapes = font.generateShapes(text, size, { lineHeight, letterSpacing });\n      super(shapes, { ...rest, bevelEnabled, bevelSize, bevelThickness, depth: height });\n    }\n    this.type = \"TextGeometry\";\n  }\n}\nexport {\n  TextGeometry as TextBufferGeometry,\n  TextGeometry\n};\n//# sourceMappingURL=TextGeometry.js.map\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, FileLoader, ShapePath } from \"three\";\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== \"string\")\n          throw new Error(\"unsupported data type\");\n        const json = JSON.parse(response);\n        const font = this.parse(json);\n        if (onLoad)\n          onLoad(font);\n      },\n      onProgress,\n      onError\n    );\n  }\n  loadAsync(url, onProgress) {\n    return super.loadAsync(url, onProgress);\n  }\n  parse(json) {\n    return new Font(json);\n  }\n}\nclass Font {\n  constructor(data) {\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  generateShapes(text, size = 100, _options) {\n    const shapes = [];\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options };\n    const paths = createPaths(text, size, this.data, options);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n    return shapes;\n  }\n}\n__publicField(Font, \"isFont\");\n__publicField(Font, \"type\");\nfunction createPaths(text, size, data, options) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0, offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs[\"?\"];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case \"l\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case \"q\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case \"b\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return { offsetX: glyph.ha * scale, path };\n}\nexport {\n  Font,\n  FontLoader\n};\n//# sourceMappingURL=FontLoader.js.map\n","import { FontLoader } from 'three-stdlib';\nimport { suspend, preload, clear } from 'suspend-react';\n\nlet fontLoader = null;\nasync function loadFontData(font) {\n  return typeof font === 'string' ? await (await fetch(font)).json() : font;\n}\nfunction parseFontData(fontData) {\n  if (!fontLoader) {\n    fontLoader = new FontLoader();\n  }\n  return fontLoader.parse(fontData);\n}\nasync function loader(font) {\n  const data = await loadFontData(font);\n  return parseFontData(data);\n}\nfunction useFont(font) {\n  return suspend(loader, [font]);\n}\nuseFont.preload = font => preload(loader, [font]);\nuseFont.clear = font => clear([font]);\n\nexport { useFont };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useMemo } from 'react';\nimport { extend } from '@react-three/fiber';\nimport { TextGeometry, mergeVertices } from 'three-stdlib';\nimport { useFont } from './useFont.js';\n\nconst types = ['string', 'number'];\nconst getTextFromChildren = children => {\n  let label = '';\n  const rest = [];\n  React.Children.forEach(children, child => {\n    if (types.includes(typeof child)) label += child + '';else rest.push(child);\n  });\n  return [label, ...rest];\n};\nconst Text3D = /* @__PURE__ */React.forwardRef(({\n  font: _font,\n  letterSpacing = 0,\n  lineHeight = 1,\n  size = 1,\n  height = 0.2,\n  bevelThickness = 0.1,\n  bevelSize = 0.01,\n  bevelEnabled = false,\n  bevelOffset = 0,\n  bevelSegments = 4,\n  curveSegments = 8,\n  smooth,\n  children,\n  ...props\n}, fref) => {\n  React.useMemo(() => extend({\n    RenamedTextGeometry: TextGeometry\n  }), []);\n  const ref = React.useRef(null);\n  const font = useFont(_font);\n  const opts = useMemo(() => {\n    return {\n      font,\n      size,\n      height,\n      bevelThickness,\n      bevelSize,\n      bevelEnabled,\n      bevelSegments,\n      bevelOffset,\n      curveSegments,\n      letterSpacing,\n      lineHeight\n    };\n  }, [font, size, height, bevelThickness, bevelSize, bevelEnabled, bevelSegments, bevelOffset, curveSegments, letterSpacing, lineHeight]);\n\n  /**\n   * We need the `children` in the deps because we\n   * need to be able to do `<Text3d>{state}</Text3d>`.\n   */\n  const [label, ...rest] = useMemo(() => getTextFromChildren(children), [children]);\n  const args = React.useMemo(() => [label, opts], [label, opts]);\n  React.useLayoutEffect(() => {\n    if (smooth) {\n      ref.current.geometry = mergeVertices(ref.current.geometry, smooth);\n      ref.current.geometry.computeVertexNormals();\n    }\n  }, [args, smooth]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({}, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"renamedTextGeometry\", {\n    args: args\n  }), rest);\n});\n\nexport { Text3D };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { Box3, Vector3, Sphere } from 'three';\nimport * as React from 'react';\n\nconst Center = /* @__PURE__ */React.forwardRef(function Center({\n  children,\n  disable,\n  disableX,\n  disableY,\n  disableZ,\n  left,\n  right,\n  top,\n  bottom,\n  front,\n  back,\n  onCentered,\n  precise = true,\n  cacheKey = 0,\n  ...props\n}, fRef) {\n  const ref = React.useRef(null);\n  const outer = React.useRef(null);\n  const inner = React.useRef(null);\n  React.useLayoutEffect(() => {\n    outer.current.matrixWorld.identity();\n    const box3 = new Box3().setFromObject(inner.current, precise);\n    const center = new Vector3();\n    const sphere = new Sphere();\n    const width = box3.max.x - box3.min.x;\n    const height = box3.max.y - box3.min.y;\n    const depth = box3.max.z - box3.min.z;\n    box3.getCenter(center);\n    box3.getBoundingSphere(sphere);\n    const vAlign = top ? height / 2 : bottom ? -height / 2 : 0;\n    const hAlign = left ? -width / 2 : right ? width / 2 : 0;\n    const dAlign = front ? depth / 2 : back ? -depth / 2 : 0;\n    outer.current.position.set(disable || disableX ? 0 : -center.x + hAlign, disable || disableY ? 0 : -center.y + vAlign, disable || disableZ ? 0 : -center.z + dAlign);\n\n    // Only fire onCentered if the bounding box has changed\n    if (typeof onCentered !== 'undefined') {\n      onCentered({\n        parent: ref.current.parent,\n        container: ref.current,\n        width,\n        height,\n        depth,\n        boundingBox: box3,\n        boundingSphere: sphere,\n        center: center,\n        verticalAlignment: vAlign,\n        horizontalAlignment: hAlign,\n        depthAlignment: dAlign\n      });\n    }\n  }, [cacheKey, onCentered, top, left, front, disable, disableX, disableY, disableZ, precise, right, bottom, back]);\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"group\", {\n    ref: outer\n  }, /*#__PURE__*/React.createElement(\"group\", {\n    ref: inner\n  }, children)));\n});\n\nexport { Center };\n","import gsap from \"gsap\";\r\n/**\r\n * File contains a collection of helper functions which multiple components use\r\n */\r\n\r\n\r\n/**\r\n * Animates the scale of the given references to create an \"in\" effect.\r\n *\r\n * @param {Array} refs - An array of references to the elements to animate.\r\n * @returns {Promise<void>} A promise that resolves when all animations are complete.\r\n * Here make sure other animations are complete before resolving.\r\n */\r\nexport async function animateIn(refs) {\r\n    const animations = refs.map((ref) =>\r\n      gsap.to(ref.current.scale, {\r\n        duration: 0.3,\r\n        x: 1.2,\r\n        y: 1.2,\r\n        z: 1.2,\r\n        ease: \"elastic.out(1,0.5)\",\r\n      })\r\n    );\r\n    await Promise.all(animations);\r\n  }\r\n  \r\n  /**\r\n   * Animates the scale of the given references to create an \"out\" effect.\r\n   *\r\n   * @param {Array} refs - An array of references to the elements to animate.\r\n   * @returns {Promise<void>} A promise that resolves when all animations are complete.\r\n   * Here make sure other animations are complete before resolving.\r\n   */\r\n  export async function animateOut(refs) {\r\n    const animations = refs.map((ref) =>\r\n      gsap.to(ref.current.scale, {\r\n        duration: 0.3,\r\n        x: 1,\r\n        y: 1,\r\n        z: 1,\r\n        ease: \"elastic.out(1,0.5)\",\r\n      })\r\n    );\r\n    await Promise.all(animations);\r\n  }\r\n  \r\n  /**\r\n   * Handles the click event for opening a site in a new tab.\r\n   * Prevents spamming the same site by introducing a delay between clicks.\r\n   *\r\n   * @param {string} site - The URL of the site to open.\r\n   * @param {boolean} recentClick - The state indicating if a recent click has occurred.\r\n   * @param {Function} setRecentClick - The function to set the recent click state.\r\n   */\r\n  export async function handleClick(site, recentClick, setRecentClick) {\r\n    // stop from spamming the same site\r\n    if (recentClick) return;\r\n  \r\n    // Set the recent click\r\n    setRecentClick(true);\r\n  \r\n    // Open the site in a new tab\r\n    window.open(site, \"_blank\");\r\n  \r\n    // wait one quarter second before allowing another click\r\n    await new Promise((r) => setTimeout(r, 250));\r\n    setRecentClick(false);\r\n  }","import { Center, Text3D } from '@react-three/drei';\r\nimport { useLoader } from '@react-three/fiber';\r\nimport * as THREE from \"three\";\r\nimport React, { forwardRef, useMemo, useRef } from 'react';\r\n\r\n/**\r\n * Holds the text for the project title in 3D space.\r\n * The text is centered using a box and the Center drei helper.\r\n * \r\n * @param {string} title The children of the component, expected to be a string.\r\n * @param {boolean} useNormal Determines whether or not we use the white matcap material or a normal material. If true, meshNormalMaterial else matcapMaterial.\r\n * @param {*} props Additional properties passed to the component and applied to the mesh.\r\n * @returns a 3d text object component.\r\n */\r\nconst TitleText3D  = forwardRef(({ title, useNormal, useStandard, ...props }, ref) =>\r\n{   \r\n    // Load 3d text matcap\r\n    const [textMatcap] = useLoader(THREE.TextureLoader, ['/matcaps/greyClay.png']);\r\n\r\n    /**\r\n     * Formats the text to fit in the 3D space\r\n     */\r\n    const projectTitle = useMemo(() => {\r\n        if (typeof title !== 'string') return '';\r\n        return title.split(' ').reduce((acc, word) => {\r\n            const lastLine = acc[acc.length - 1];\r\n            if (lastLine && (lastLine + ' ' + word).length <= 45) {\r\n                acc[acc.length - 1] = lastLine + ' ' + word;\r\n            } else {\r\n                acc.push(word);\r\n            }\r\n            return acc;\r\n        }, []).join('\\n');\r\n    }, [title]);\r\n\r\n    // Attach the ref\r\n    const groupRef = useRef();\r\n    if(ref)\r\n    {\r\n        ref.current = groupRef.current;\r\n    }\r\n\r\n    return (\r\n        <mesh {...props} ref={groupRef} > \r\n            <boxGeometry args={[0.1,0.1,0.1]} />\r\n            <meshBasicMaterial color={'#FFFFFF'} visible={false} />\r\n            {/* Centered Text within box */}\r\n            <Center key={projectTitle.slice(0, 5)}>\r\n                <Text3D\r\n                    scale={ 0.1 }\r\n                    key={`Textddd`}\r\n                    curveSegments={32}\r\n                    bevelEnabled\r\n                    bevelSize={0.04}\r\n                    bevelThickness={0.1}\r\n                    height={0.5}\r\n                    lineHeight={0.5}\r\n                    letterSpacing={-0.06}\r\n                    size={1}\r\n                    font=\"/fonts/Inter_Bold.json\"\r\n                >\r\n                    {projectTitle}\r\n                {/* Determine the material type based on the parameter */}\r\n                {useNormal ? <meshNormalMaterial /> : useStandard ? <meshLambertMaterial color={'#D3D3D3'}/> : <meshMatcapMaterial matcap={textMatcap} /> }\r\n                </Text3D>\r\n            </Center>\r\n        </mesh>\r\n    );\r\n});\r\n\r\nexport default TitleText3D;","import {\n\tAnimationClip,\n\tAnimationMixer,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector3,\n\tVectorKeyframeTrack\n} from 'three';\n\nfunction getBoneName( bone, options ) {\n\n\tif ( options.getBoneName !== undefined ) {\n\n\t\treturn options.getBoneName( bone );\n\n\t}\n\n\treturn options.names[ bone.name ];\n\n}\n\nfunction retarget( target, source, options = {} ) {\n\n\tconst quat = new Quaternion(),\n\t\tscale = new Vector3(),\n\t\trelativeMatrix = new Matrix4(),\n\t\tglobalMatrix = new Matrix4();\n\n\toptions.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;\n\toptions.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\toptions.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3( 1, 1, 1 );\n\toptions.scale = options.scale !== undefined ? options.scale : 1;\n\toptions.names = options.names || {};\n\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\n\n\tlet bone, name, boneTo,\n\t\tbonesPosition;\n\n\t// reset bones\n\n\tif ( target.isObject3D ) {\n\n\t\ttarget.skeleton.pose();\n\n\t} else {\n\n\t\toptions.useTargetMatrix = true;\n\t\toptions.preserveBoneMatrix = false;\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tbonesPosition = [];\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// reset matrix\n\n\t\ttarget.updateMatrixWorld();\n\n\t\ttarget.matrixWorld.identity();\n\n\t\t// reset children matrix\n\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\n\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t}\n\n\t}\n\n\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\tbone = bones[ i ];\n\t\tname = getBoneName( bone, options );\n\n\t\tboneTo = getBoneByName( name, sourceBones );\n\n\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\tif ( boneTo ) {\n\n\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// ignore scale to extract rotation\n\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t// apply to global matrix\n\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\tif ( options.localOffsets ) {\n\n\t\t\t\t\tif ( options.localOffsets[ bone.name ] ) {\n\n\t\t\t\t\t\tglobalMatrix.multiply( options.localOffsets[ bone.name ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t}\n\n\t\tif ( name === options.hip ) {\n\n\t\t\tglobalMatrix.elements[ 12 ] *= options.scale * options.hipInfluence.x;\n\t\t\tglobalMatrix.elements[ 13 ] *= options.scale * options.hipInfluence.y;\n\t\t\tglobalMatrix.elements[ 14 ] *= options.scale * options.hipInfluence.z;\n\n\t\t\tif ( options.hipPosition !== undefined ) {\n\n\t\t\t\tglobalMatrix.elements[ 12 ] += options.hipPosition.x * options.scale;\n\t\t\t\tglobalMatrix.elements[ 13 ] += options.hipPosition.y * options.scale;\n\t\t\t\tglobalMatrix.elements[ 14 ] += options.hipPosition.z * options.scale;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( bone.parent ) {\n\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t} else {\n\n\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t}\n\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\tbone.updateMatrixWorld();\n\n\t}\n\n\tif ( options.preserveBonePositions ) {\n\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\n\n\t\t\tbone = bones[ i ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\n\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif ( options.preserveBoneMatrix ) {\n\n\t\t// restore matrix\n\n\t\ttarget.updateMatrixWorld( true );\n\n\t}\n\n}\n\nfunction retargetClip( target, source, clip, options = {} ) {\n\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\n\t// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\n\toptions.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );\n\toptions.names = options.names || [];\n\n\tif ( ! source.isObject3D ) {\n\n\t\tsource = getHelperFromSkeleton( source );\n\n\t}\n\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\tdelta = clip.duration / ( numFrames - 1 ),\n\t\tconvertedTracks = [],\n\t\tmixer = new AnimationMixer( source ),\n\t\tbones = getBones( target.skeleton ),\n\t\tboneDatas = [];\n\n\tlet positionOffset,\n\t\tbone, boneTo, boneData,\n\t\tname;\n\n\tmixer.clipAction( clip ).play();\n\n\t// trim\n\n\tlet start = 0, end = numFrames;\n\n\tif ( options.trim !== undefined ) {\n\n\t\tstart = Math.round( options.trim[ 0 ] * options.fps );\n\t\tend = Math.min( Math.round( options.trim[ 1 ] * options.fps ), numFrames ) - start;\n\n\t\tmixer.update( options.trim[ 0 ] );\n\n\t} else {\n\n\t\tmixer.update( 0 );\n\n\t}\n\n\tsource.updateMatrixWorld();\n\n\t//\n\n\tfor ( let frame = 0; frame < end; ++ frame ) {\n\n\t\tconst time = frame * delta;\n\n\t\tretarget( target, source, options );\n\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\n\n\t\t\tbone = bones[ j ];\n\t\t\tname = getBoneName( bone, options ) || bone.name;\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\n\n\t\t\tif ( boneTo ) {\n\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\t\tvalues: new Float32Array( end * 3 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\tif ( frame === 0 ) {\n\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.pos.times[ frame ] = time;\n\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, frame * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\ttimes: new Float32Array( end ),\n\t\t\t\t\t\tvalues: new Float32Array( end * 4 )\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tboneData.quat.times[ frame ] = time;\n\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, frame * 4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( frame === end - 2 ) {\n\n\t\t\t// last mixer update before final loop iteration\n\t\t\t// make sure we do not go over or equal to clip duration\n\t\t\tmixer.update( delta - 0.0000001 );\n\n\t\t} else {\n\n\t\t\tmixer.update( delta );\n\n\t\t}\n\n\t\tsource.updateMatrixWorld();\n\n\t}\n\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\n\n\t\tboneData = boneDatas[ i ];\n\n\t\tif ( boneData ) {\n\n\t\t\tif ( boneData.pos ) {\n\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\tboneData.pos.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\tboneData.quat.times,\n\t\t\t\tboneData.quat.values\n\t\t\t) );\n\n\t\t}\n\n\t}\n\n\tmixer.uncacheAction( clip );\n\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n}\n\nfunction clone( source ) {\n\n\tconst sourceLookup = new Map();\n\tconst cloneLookup = new Map();\n\n\tconst clone = source.clone();\n\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t} );\n\n\tclone.traverse( function ( node ) {\n\n\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\tconst clonedMesh = node;\n\t\tconst sourceMesh = sourceLookup.get( node );\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\n\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\treturn cloneLookup.get( bone );\n\n\t\t} );\n\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t} );\n\n\treturn clone;\n\n}\n\n// internal helper\n\nfunction getBoneByName( name, skeleton ) {\n\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\tif ( name === bones[ i ].name )\n\n\t\t\treturn bones[ i ];\n\n\t}\n\n}\n\nfunction getBones( skeleton ) {\n\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n}\n\n\nfunction getHelperFromSkeleton( skeleton ) {\n\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\tsource.skeleton = skeleton;\n\n\treturn source;\n\n}\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport {\n\tretarget,\n\tretargetClip,\n\tclone,\n};\n","import { useGLTF } from '@react-three/drei';\r\nimport { forwardRef, useRef } from 'react';\r\nimport { clone } from 'three/examples/jsm/utils/SkeletonUtils.js';\r\n\r\n/**\r\n * Returns a logo object in 3D space.\r\n * @param {*} props Additional properties passed to the component, which are applied to the mesh.\r\n * @returns A 3d logo object component.\r\n */\r\nconst Logo = forwardRef(({ kind, ...props }, ref) => {  \r\n\r\n    /**\r\n     * State for the logo kind\r\n     */\r\n    const logoKind = kind || 'linkedin';\r\n    let logoPath;\r\n\r\n    if (logoKind === 'github') {\r\n        logoPath = '/models/socialMediaIcons/github.glb';\r\n    } else if (logoKind === 'email') {\r\n        logoPath = '/models/socialMediaIcons/email.glb';\r\n    } else if (logoKind === 'website') {\r\n        logoPath = \"models/socialMediaIcons/website-icon/source/website.glb\";\r\n    } else {\r\n        logoPath = '/models/socialMediaIcons/linkedin.glb';\r\n    }\r\n    \r\n    // Model file\r\n    const logoModel = useGLTF(logoPath);\r\n    let clonedLogo;\r\n\r\n    // Clone the model\r\n    if (logoKind === 'email') {\r\n        clonedLogo = clone(logoModel.scene.children[0].children[0].children[0].children[0]);\r\n    } else {\r\n        clonedLogo = clone(logoModel.scene.children[0]);\r\n    }\r\n\r\n    // Set logo position and rotation\r\n    clonedLogo.position.set(0, 0, 0);\r\n    clonedLogo.rotation.set(Math.PI / 2, 0, Math.PI / 2);\r\n\r\n    // Set the object's scale\r\n    if (logoKind === 'github') \r\n    {\r\n        clonedLogo.scale.set(10, 10, 10);\r\n    } else if (logoKind === 'email') \r\n    {\r\n        // Set logo position\r\n        clonedLogo.position.set(0, -0.1, 0);\r\n\r\n        // Scale and Rotation\r\n        clonedLogo.scale.set(0.03, 0.03, 0.03);\r\n        clonedLogo.rotation.set(0, -Math.PI / 2, 0);\r\n    } else if (logoKind === 'website') {\r\n\r\n        // Website logo\r\n        clonedLogo.scale.set(0.035, 0.035, 0.035);\r\n        clonedLogo.position.set(0.15, 0, 0);\r\n    } else {\r\n        // LinkedIn logo\r\n        clonedLogo.scale.set(0.3, 0.3, 0.3);\r\n    }\r\n\r\n    // Attach the ref\r\n    const groupRef = useRef();\r\n    if(ref)\r\n    {\r\n        ref.current = groupRef.current;\r\n    }\r\n\r\n    return (\r\n        <group {...props} ref={groupRef}>\r\n            {/* Box the size of the logo so we can figure out hover without using complex geom */}\r\n            <mesh>\r\n                <boxGeometry args={[1, 1, 1]} />\r\n                <meshBasicMaterial color={'#FFFFFF'} visible={false} />\r\n            </mesh>\r\n            <primitive object={clonedLogo}/>\r\n        </group>\r\n    )\r\n})\r\n\r\nexport default Logo;"],"names":["TextGeometry","ExtrudeGeometry","text","parameters","bevelEnabled","bevelSize","bevelThickness","font","height","size","lineHeight","letterSpacing","rest","shapes","__defProp","__defNormalProp","obj","key","value","__publicField","FontLoader","Loader","manager","url","onLoad","onProgress","onError","loader","FileLoader","response","json","Font","data","_options","options","paths","createPaths","p","pl","chars","scale","line_height","offsetX","offsetY","i","char","ret","createPath","glyph","path","ShapePath","x","y","cpx","cpy","cpx1","cpy1","cpx2","cpy2","outline","l","fontLoader","loadFontData","parseFontData","fontData","useFont","suspend","preload","clear","types","getTextFromChildren","children","label","React.Children","child","Text3D","React.forwardRef","_font","bevelOffset","bevelSegments","curveSegments","smooth","props","fref","React.useMemo","extend","ref","React.useRef","opts","useMemo","args","React.useLayoutEffect","mergeVertices","React.useImperativeHandle","React.createElement","_extends","Center","disable","disableX","disableY","disableZ","left","right","top","bottom","front","back","onCentered","precise","cacheKey","fRef","outer","inner","box3","Box3","center","Vector3","sphere","Sphere","width","depth","vAlign","hAlign","dAlign","animateIn","refs","animations","gsap","animateOut","handleClick","site","recentClick","setRecentClick","r","TitleText3D","forwardRef","title","useNormal","useStandard","textMatcap","useLoader","THREE.TextureLoader","projectTitle","acc","word","lastLine","groupRef","useRef","jsxs","jsx","clone","source","sourceLookup","cloneLookup","parallelTraverse","sourceNode","clonedNode","node","clonedMesh","sourceMesh","sourceBones","bone","a","b","callback","Logo","kind","logoKind","logoPath","logoModel","useGLTF","clonedLogo"],"mappings":"kKACA,MAAMA,WAAqBC,CAAgB,CACzC,YAAYC,EAAMC,EAAa,GAAI,CACjC,KAAM,CACJ,aAAAC,EAAe,GACf,UAAAC,EAAY,EACZ,eAAAC,EAAiB,GACjB,KAAAC,EACA,OAAAC,EAAS,GACT,KAAAC,EAAO,IACP,WAAAC,EAAa,EACb,cAAAC,EAAgB,EAChB,GAAGC,CACT,EAAQT,EACJ,GAAII,IAAS,OACX,MAAO,MACF,CACL,MAAMM,EAASN,EAAK,eAAeL,EAAMO,EAAM,CAAE,WAAAC,EAAY,cAAAC,EAAe,EAC5E,MAAME,EAAQ,CAAE,GAAGD,EAAM,aAAAR,EAAc,UAAAC,EAAW,eAAAC,EAAgB,MAAOE,EAAQ,CACvF,CACI,KAAK,KAAO,cAChB,CACA,CCtBA,IAAIM,GAAY,OAAO,eACnBC,GAAkB,CAACC,EAAKC,EAAKC,IAAUD,KAAOD,EAAMF,GAAUE,EAAKC,EAAK,CAAE,WAAY,GAAM,aAAc,GAAM,SAAU,GAAM,MAAAC,CAAK,CAAE,EAAIF,EAAIC,CAAG,EAAIC,EACtJC,EAAgB,CAACH,EAAKC,EAAKC,KAC7BH,GAAgBC,EAAK,OAAOC,GAAQ,SAAWA,EAAM,GAAKA,EAAKC,CAAK,EAC7DA,GAGT,MAAME,WAAmBC,CAAO,CAC9B,YAAYC,EAAS,CACnB,MAAMA,CAAO,CACjB,CACE,KAAKC,EAAKC,EAAQC,EAAYC,EAAS,CACrC,MAAMC,EAAS,IAAIC,EAAW,KAAK,OAAO,EAC1CD,EAAO,QAAQ,KAAK,IAAI,EACxBA,EAAO,iBAAiB,KAAK,aAAa,EAC1CA,EAAO,mBAAmB,KAAK,eAAe,EAC9CA,EAAO,KACLJ,EACCM,GAAa,CACZ,GAAI,OAAOA,GAAa,SACtB,MAAM,IAAI,MAAM,uBAAuB,EACzC,MAAMC,EAAO,KAAK,MAAMD,CAAQ,EAC1BtB,EAAO,KAAK,MAAMuB,CAAI,EACxBN,GACFA,EAAOjB,CAAI,CACd,EACDkB,EACAC,CACD,CACL,CACE,UAAUH,EAAKE,EAAY,CACzB,OAAO,MAAM,UAAUF,EAAKE,CAAU,CAC1C,CACE,MAAMK,EAAM,CACV,OAAO,IAAIC,EAAKD,CAAI,CACxB,CACA,CACA,MAAMC,CAAK,CACT,YAAYC,EAAM,CAChBb,EAAc,KAAM,MAAM,EAC1B,KAAK,KAAOa,CAChB,CACE,eAAe9B,EAAMO,EAAO,IAAKwB,EAAU,CACzC,MAAMpB,EAAS,CAAE,EACXqB,EAAU,CAAE,cAAe,EAAG,WAAY,EAAG,GAAGD,CAAU,EAC1DE,EAAQC,GAAYlC,EAAMO,EAAM,KAAK,KAAMyB,CAAO,EACxD,QAASG,EAAI,EAAGC,EAAKH,EAAM,OAAQE,EAAIC,EAAID,IACzC,MAAM,UAAU,KAAK,MAAMxB,EAAQsB,EAAME,CAAC,EAAE,SAAS,EAAK,CAAC,EAE7D,OAAOxB,CACX,CACA,CACAM,EAAcY,EAAM,QAAQ,EAC5BZ,EAAcY,EAAM,MAAM,EAC1B,SAASK,GAAYlC,EAAMO,EAAMuB,EAAME,EAAS,CAC9C,MAAMK,EAAQ,MAAM,KAAKrC,CAAI,EACvBsC,EAAQ/B,EAAOuB,EAAK,WACpBS,GAAeT,EAAK,YAAY,KAAOA,EAAK,YAAY,KAAOA,EAAK,oBAAsBQ,EAC1FL,EAAQ,CAAE,EAChB,IAAIO,EAAU,EAAGC,EAAU,EAC3B,QAASC,EAAI,EAAGA,EAAIL,EAAM,OAAQK,IAAK,CACrC,MAAMC,EAAON,EAAMK,CAAC,EACpB,GAAIC,IAAS;AAAA,EACXH,EAAU,EACVC,GAAWF,EAAcP,EAAQ,eAC5B,CACL,MAAMY,EAAMC,GAAWF,EAAML,EAAOE,EAASC,EAASX,CAAI,EACtDc,IACFJ,GAAWI,EAAI,QAAUZ,EAAQ,cACjCC,EAAM,KAAKW,EAAI,IAAI,EAE3B,CACA,CACE,OAAOX,CACT,CACA,SAASY,GAAWF,EAAML,EAAOE,EAASC,EAASX,EAAM,CACvD,MAAMgB,EAAQhB,EAAK,OAAOa,CAAI,GAAKb,EAAK,OAAO,GAAG,EAClD,GAAI,CAACgB,EAAO,CACV,QAAQ,MAAM,0BAA4BH,EAAO,oCAAsCb,EAAK,WAAa,GAAG,EAC5G,MACJ,CACE,MAAMiB,EAAO,IAAIC,EACjB,IAAIC,EAAGC,EAAGC,EAAKC,EAAKC,EAAMC,EAAMC,EAAMC,EACtC,GAAIV,EAAM,EAAG,CACX,MAAMW,EAAUX,EAAM,iBAAmBA,EAAM,eAAiBA,EAAM,EAAE,MAAM,GAAG,GACjF,QAASJ,EAAI,EAAGgB,EAAID,EAAQ,OAAQf,EAAIgB,GAEtC,OADeD,EAAQf,GAAG,EACZ,CACZ,IAAK,IACHO,EAAI,SAASQ,EAAQf,GAAG,CAAC,EAAIJ,EAAQE,EACrCU,EAAI,SAASO,EAAQf,GAAG,CAAC,EAAIJ,EAAQG,EACrCM,EAAK,OAAOE,EAAGC,CAAC,EAChB,MACF,IAAK,IACHD,EAAI,SAASQ,EAAQf,GAAG,CAAC,EAAIJ,EAAQE,EACrCU,EAAI,SAASO,EAAQf,GAAG,CAAC,EAAIJ,EAAQG,EACrCM,EAAK,OAAOE,EAAGC,CAAC,EAChB,MACF,IAAK,IACHC,EAAM,SAASM,EAAQf,GAAG,CAAC,EAAIJ,EAAQE,EACvCY,EAAM,SAASK,EAAQf,GAAG,CAAC,EAAIJ,EAAQG,EACvCY,EAAO,SAASI,EAAQf,GAAG,CAAC,EAAIJ,EAAQE,EACxCc,EAAO,SAASG,EAAQf,GAAG,CAAC,EAAIJ,EAAQG,EACxCM,EAAK,iBAAiBM,EAAMC,EAAMH,EAAKC,CAAG,EAC1C,MACF,IAAK,IACHD,EAAM,SAASM,EAAQf,GAAG,CAAC,EAAIJ,EAAQE,EACvCY,EAAM,SAASK,EAAQf,GAAG,CAAC,EAAIJ,EAAQG,EACvCY,EAAO,SAASI,EAAQf,GAAG,CAAC,EAAIJ,EAAQE,EACxCc,EAAO,SAASG,EAAQf,GAAG,CAAC,EAAIJ,EAAQG,EACxCc,EAAO,SAASE,EAAQf,GAAG,CAAC,EAAIJ,EAAQE,EACxCgB,EAAO,SAASC,EAAQf,GAAG,CAAC,EAAIJ,EAAQG,EACxCM,EAAK,cAAcM,EAAMC,EAAMC,EAAMC,EAAML,EAAKC,CAAG,EACnD,KACV,CAEA,CACE,MAAO,CAAE,QAASN,EAAM,GAAKR,EAAO,KAAAS,CAAM,CAC5C,CCnHA,IAAIY,EAAa,KACjB,eAAeC,GAAavD,EAAM,CAChC,OAAO,OAAOA,GAAS,SAAW,MAAO,MAAM,MAAMA,CAAI,GAAG,KAAI,EAAKA,CACvE,CACA,SAASwD,GAAcC,EAAU,CAC/B,OAAKH,IACHA,EAAa,IAAIzC,IAEZyC,EAAW,MAAMG,CAAQ,CAClC,CACA,eAAerC,EAAOpB,EAAM,CAC1B,MAAMyB,EAAO,MAAM8B,GAAavD,CAAI,EACpC,OAAOwD,GAAc/B,CAAI,CAC3B,CACA,SAASiC,EAAQ1D,EAAM,CACrB,OAAO2D,EAAQvC,EAAQ,CAACpB,CAAI,CAAC,CAC/B,CACA0D,EAAQ,QAAU1D,GAAQ4D,EAAQxC,EAAQ,CAACpB,CAAI,CAAC,EAChD0D,EAAQ,MAAQ1D,GAAQ6D,EAAM,CAAC7D,CAAI,CAAC,ECdpC,MAAM8D,GAAQ,CAAC,SAAU,QAAQ,EAC3BC,GAAsBC,GAAY,CACtC,IAAIC,EAAQ,GACZ,MAAM5D,EAAO,CAAE,EACf6D,OAAAA,WAAe,QAAQF,EAAUG,GAAS,CACpCL,GAAM,SAAS,OAAOK,CAAK,EAAGF,GAASE,EAAQ,GAAQ9D,EAAK,KAAK8D,CAAK,CAC9E,CAAG,EACM,CAACF,EAAO,GAAG5D,CAAI,CACxB,EACM+D,GAAwBC,EAAgB,WAAC,CAAC,CAC9C,KAAMC,EACN,cAAAlE,EAAgB,EAChB,WAAAD,EAAa,EACb,KAAAD,EAAO,EACP,OAAAD,EAAS,GACT,eAAAF,EAAiB,GACjB,UAAAD,EAAY,IACZ,aAAAD,EAAe,GACf,YAAA0E,EAAc,EACd,cAAAC,EAAgB,EAChB,cAAAC,EAAgB,EAChB,OAAAC,EACA,SAAAV,EACA,GAAGW,CACL,EAAGC,IAAS,CACVC,EAAa,QAAC,IAAMC,EAAO,CACzB,oBAAqBrF,EACtB,CAAA,EAAG,CAAA,CAAE,EACN,MAAMsF,EAAMC,EAAY,OAAC,IAAI,EACvBhF,EAAO0D,EAAQY,CAAK,EACpBW,EAAOC,EAAAA,QAAQ,KACZ,CACL,KAAAlF,EACA,KAAAE,EACA,OAAAD,EACA,eAAAF,EACA,UAAAD,EACA,aAAAD,EACA,cAAA2E,EACA,YAAAD,EACA,cAAAE,EACA,cAAArE,EACA,WAAAD,CACD,GACA,CAACH,EAAME,EAAMD,EAAQF,EAAgBD,EAAWD,EAAc2E,EAAeD,EAAaE,EAAerE,EAAeD,CAAU,CAAC,EAMhI,CAAC8D,EAAO,GAAG5D,CAAI,EAAI6E,EAAAA,QAAQ,IAAMnB,GAAoBC,CAAQ,EAAG,CAACA,CAAQ,CAAC,EAC1EmB,EAAON,EAAa,QAAC,IAAM,CAACZ,EAAOgB,CAAI,EAAG,CAAChB,EAAOgB,CAAI,CAAC,EAC7DG,OAAAA,EAAAA,gBAAsB,IAAM,CACtBV,IACFK,EAAI,QAAQ,SAAWM,EAAcN,EAAI,QAAQ,SAAUL,CAAM,EACjEK,EAAI,QAAQ,SAAS,qBAAsB,EAEjD,EAAK,CAACI,EAAMT,CAAM,CAAC,EACjBY,EAAAA,oBAA0BV,EAAM,IAAMG,EAAI,QAAS,CAAA,CAAE,EACjCQ,EAAmB,cAAC,OAAQC,EAAS,CAAA,EAAIb,EAAO,CAClE,IAAKI,CACT,CAAG,EAAgBQ,EAAmB,cAAC,sBAAuB,CAC1D,KAAMJ,CACP,CAAA,EAAG9E,CAAI,CACV,CAAC,ECnEKoF,GAAwBpB,EAAAA,WAAiB,SAAgB,CAC7D,SAAAL,EACA,QAAA0B,EACA,SAAAC,EACA,SAAAC,EACA,SAAAC,EACA,KAAAC,EACA,MAAAC,EACA,IAAAC,EACA,OAAAC,EACA,MAAAC,EACA,KAAAC,EACA,WAAAC,EACA,QAAAC,EAAU,GACV,SAAAC,EAAW,EACX,GAAG3B,CACL,EAAG4B,EAAM,CACP,MAAMxB,EAAMC,EAAY,OAAC,IAAI,EACvBwB,EAAQxB,EAAY,OAAC,IAAI,EACzByB,EAAQzB,EAAY,OAAC,IAAI,EAC/BI,OAAAA,EAAAA,gBAAsB,IAAM,CAC1BoB,EAAM,QAAQ,YAAY,SAAU,EACpC,MAAME,EAAO,IAAIC,EAAM,EAAC,cAAcF,EAAM,QAASJ,CAAO,EACtDO,EAAS,IAAIC,EACbC,EAAS,IAAIC,EACbC,EAAQN,EAAK,IAAI,EAAIA,EAAK,IAAI,EAC9BzG,EAASyG,EAAK,IAAI,EAAIA,EAAK,IAAI,EAC/BO,EAAQP,EAAK,IAAI,EAAIA,EAAK,IAAI,EACpCA,EAAK,UAAUE,CAAM,EACrBF,EAAK,kBAAkBI,CAAM,EAC7B,MAAMI,EAASlB,EAAM/F,EAAS,EAAIgG,EAAS,CAAChG,EAAS,EAAI,EACnDkH,EAASrB,EAAO,CAACkB,EAAQ,EAAIjB,EAAQiB,EAAQ,EAAI,EACjDI,EAASlB,EAAQe,EAAQ,EAAId,EAAO,CAACc,EAAQ,EAAI,EACvDT,EAAM,QAAQ,SAAS,IAAId,GAAWC,EAAW,EAAI,CAACiB,EAAO,EAAIO,EAAQzB,GAAWE,EAAW,EAAI,CAACgB,EAAO,EAAIM,EAAQxB,GAAWG,EAAW,EAAI,CAACe,EAAO,EAAIQ,CAAM,EAG/J,OAAOhB,EAAe,KACxBA,EAAW,CACT,OAAQrB,EAAI,QAAQ,OACpB,UAAWA,EAAI,QACf,MAAAiC,EACA,OAAA/G,EACA,MAAAgH,EACA,YAAaP,EACb,eAAgBI,EAChB,OAAQF,EACR,kBAAmBM,EACnB,oBAAqBC,EACrB,eAAgBC,CACxB,CAAO,CAEP,EAAK,CAACd,EAAUF,EAAYJ,EAAKF,EAAMI,EAAOR,EAASC,EAAUC,EAAUC,EAAUQ,EAASN,EAAOE,EAAQE,CAAI,CAAC,EAChHb,EAAAA,oBAA0BiB,EAAM,IAAMxB,EAAI,QAAS,CAAA,CAAE,EACjCQ,EAAmB,cAAC,QAASC,EAAS,CACxD,IAAKT,CACT,EAAKJ,CAAK,EAAgBY,EAAmB,cAAC,QAAS,CACnD,IAAKiB,CACT,EAAkBjB,EAAAA,cAAoB,QAAS,CAC3C,IAAKkB,CACT,EAAKzC,CAAQ,CAAC,CAAC,CACf,CAAC,ECnDD,eAAsBqD,GAAUC,EAAM,CAClC,MAAMC,EAAaD,EAAK,IAAKvC,GAC3ByC,EAAK,GAAGzC,EAAI,QAAQ,MAAO,CACzB,SAAU,GACV,EAAG,IACH,EAAG,IACH,EAAG,IACH,KAAM,oBACP,CAAA,CACH,EACM,MAAA,QAAQ,IAAIwC,CAAU,CAC9B,CASA,eAAsBE,GAAWH,EAAM,CACrC,MAAMC,EAAaD,EAAK,IAAKvC,GAC3ByC,EAAK,GAAGzC,EAAI,QAAQ,MAAO,CACzB,SAAU,GACV,EAAG,EACH,EAAG,EACH,EAAG,EACH,KAAM,oBACP,CAAA,CACH,EACM,MAAA,QAAQ,IAAIwC,CAAU,CAC9B,CAUsB,eAAAG,GAAYC,EAAMC,EAAaC,EAAgB,CAE/DD,IAGJC,EAAe,EAAI,EAGZ,OAAA,KAAKF,EAAM,QAAQ,EAG1B,MAAM,IAAI,QAASG,GAAM,WAAWA,EAAG,GAAG,CAAC,EAC3CD,EAAe,EAAK,EACtB,CCrDI,MAAAE,GAAeC,EAAAA,WAAW,CAAC,CAAE,MAAAC,EAAO,UAAAC,EAAW,YAAAC,EAAa,GAAGxD,CAAM,EAAGI,IAC9E,CAEU,KAAA,CAACqD,CAAU,EAAIC,EAAUC,EAAqB,CAAC,uBAAuB,CAAC,EAKvEC,EAAerD,EAAAA,QAAQ,IACrB,OAAO+C,GAAU,SAAiB,GAC/BA,EAAM,MAAM,GAAG,EAAE,OAAO,CAACO,EAAKC,IAAS,CAC1C,MAAMC,EAAWF,EAAIA,EAAI,OAAS,CAAC,EACnC,OAAIE,IAAaA,EAAW,IAAMD,GAAM,QAAU,GAC9CD,EAAIA,EAAI,OAAS,CAAC,EAAIE,EAAW,IAAMD,EAEvCD,EAAI,KAAKC,CAAI,EAEVD,CAAA,EACR,CAAE,CAAA,EAAE,KAAK;AAAA,CAAI,EACjB,CAACP,CAAK,CAAC,EAGJU,EAAWC,EAAAA,OAAO,EACxB,OAAG7D,IAECA,EAAI,QAAU4D,EAAS,SAItBE,EAAAA,KAAA,OAAA,CAAM,GAAGlE,EAAO,IAAKgE,EAClB,SAAA,CAAAG,EAAA,IAAC,eAAY,KAAM,CAAC,GAAI,GAAI,EAAG,EAAG,EACjCA,EAAA,IAAA,oBAAA,CAAkB,MAAO,UAAW,QAAS,GAAO,QAEpDrD,GACG,CAAA,SAAAoD,EAAA,KAACzE,GAAA,CACG,MAAQ,GAER,cAAe,GACf,aAAY,GACZ,UAAW,IACX,eAAgB,GAChB,OAAQ,GACR,WAAY,GACZ,cAAe,KACf,KAAM,EACN,KAAK,yBAEJ,SAAA,CAAAmE,EAEJL,EAAYY,EAAA,IAAC,qBAAmB,CAAA,CAAA,EAAKX,EAAcW,EAAAA,IAAC,sBAAoB,CAAA,MAAO,SAAU,CAAA,EAAMA,EAAAA,IAAA,qBAAA,CAAmB,OAAQV,CAAY,CAAA,CAAA,CAAA,EAb9H,SAHA,CAAA,EAAAG,EAAa,MAAM,EAAG,CAAC,CAkBpC,CAAA,EACJ,CAER,CAAC,ECgSD,SAASQ,EAAOC,EAAS,CAExB,MAAMC,EAAe,IAAI,IACnBC,EAAc,IAAI,IAElBH,EAAQC,EAAO,MAAO,EAE5B,OAAAG,EAAkBH,EAAQD,EAAO,SAAWK,EAAYC,EAAa,CAEpEJ,EAAa,IAAKI,EAAYD,CAAY,EAC1CF,EAAY,IAAKE,EAAYC,CAAY,CAE3C,CAAI,EAEHN,EAAM,SAAU,SAAWO,EAAO,CAEjC,GAAK,CAAEA,EAAK,cAAgB,OAE5B,MAAMC,EAAaD,EACbE,EAAaP,EAAa,IAAKK,CAAM,EACrCG,EAAcD,EAAW,SAAS,MAExCD,EAAW,SAAWC,EAAW,SAAS,MAAO,EACjDD,EAAW,WAAW,KAAMC,EAAW,UAAY,EAEnDD,EAAW,SAAS,MAAQE,EAAY,IAAK,SAAWC,EAAO,CAE9D,OAAOR,EAAY,IAAKQ,CAAM,CAEjC,CAAK,EAEHH,EAAW,KAAMA,EAAW,SAAUA,EAAW,UAAY,CAE/D,CAAI,EAEIR,CAER,CAgCA,SAASI,EAAkBQ,EAAGC,EAAGC,EAAW,CAE3CA,EAAUF,EAAGC,CAAG,EAEhB,QAAUvH,EAAI,EAAGA,EAAIsH,EAAE,SAAS,OAAQtH,IAEvC8G,EAAkBQ,EAAE,SAAUtH,CAAC,EAAIuH,EAAE,SAAUvH,CAAG,EAAEwH,CAAU,CAIhE,CC1aM,MAAAC,GAAO9B,aAAW,CAAC,CAAE,KAAA+B,EAAM,GAAGpF,GAASI,IAAQ,CAKjD,MAAMiF,EAAWD,GAAQ,WACrB,IAAAE,EAEAD,IAAa,SACFC,EAAA,sCACJD,IAAa,QACTC,EAAA,qCACJD,IAAa,UACTC,EAAA,0DAEAA,EAAA,wCAIT,MAAAC,EAAYC,GAAQF,CAAQ,EAC9B,IAAAG,EAGAJ,IAAa,QACbI,EAAarB,EAAMmB,EAAU,MAAM,SAAS,CAAC,EAAE,SAAS,CAAC,EAAE,SAAS,CAAC,EAAE,SAAS,CAAC,CAAC,EAElFE,EAAarB,EAAMmB,EAAU,MAAM,SAAS,CAAC,CAAC,EAIlDE,EAAW,SAAS,IAAI,EAAG,EAAG,CAAC,EACpBA,EAAA,SAAS,IAAI,KAAK,GAAK,EAAG,EAAG,KAAK,GAAK,CAAC,EAG/CJ,IAAa,SAEbI,EAAW,MAAM,IAAI,GAAI,GAAI,EAAE,EACxBJ,IAAa,SAGpBI,EAAW,SAAS,IAAI,EAAG,IAAM,CAAC,EAGlCA,EAAW,MAAM,IAAI,IAAM,IAAM,GAAI,EACrCA,EAAW,SAAS,IAAI,EAAG,CAAC,KAAK,GAAK,EAAG,CAAC,GACnCJ,IAAa,WAGpBI,EAAW,MAAM,IAAI,KAAO,KAAO,IAAK,EACxCA,EAAW,SAAS,IAAI,IAAM,EAAG,CAAC,GAGlCA,EAAW,MAAM,IAAI,GAAK,GAAK,EAAG,EAItC,MAAMzB,EAAWC,EAAAA,OAAO,EACxB,OAAG7D,IAECA,EAAI,QAAU4D,EAAS,SAItBE,EAAAA,KAAA,QAAA,CAAO,GAAGlE,EAAO,IAAKgE,EAEnB,SAAA,CAAAE,OAAC,OACG,CAAA,SAAA,CAAAC,EAAA,IAAC,eAAY,KAAM,CAAC,EAAG,EAAG,CAAC,EAAG,EAC7BA,EAAA,IAAA,oBAAA,CAAkB,MAAO,UAAW,QAAS,EAAO,CAAA,CAAA,EACzD,EACAA,EAAAA,IAAC,YAAU,CAAA,OAAQsB,CAAW,CAAA,CAAA,EAClC,CAER,CAAC","x_google_ignoreList":[0,1,2,3,4,7]}